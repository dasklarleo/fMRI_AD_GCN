# 程序思路

## correlation

`input:BatchSize*ROIs*BOLDSignals`

`output:BatchSize*heads*ROIs*ROIs`, each value in it means the correlation between one ROI and another ROI
1. Affine: get the Q,K,V
   1. `Q:BatchSize*ROIs*heads*q`
   2. `K:BatchSize*ROIs*heads*k=BatchSize*ROIs*heads*q`
   3. `Q:BatchSize*ROIs*heads*v`

2. Re-allign:
   1. `Q:BatchSize*heads*ROIs*q`
   2. `K:BatchSize*heads*ROIs*q`
   3. `Q:BatchSize*ROIs*v*heads`
3. Calculate the relation
   1. $\frac {QK^T}{\sqrt d}$, output `BatchSize*heads*ROIs*ROIs`
   2. Moved ReLU
   3. Softmax 

## SE algorithm

input: 
-  AdjacencyMatrix: `BatchSize*heads*ROIs*ROIs`
-  SE parameter: `r`

Algorithms: 
-  GAP
-  GMP(Global Maxive Pooling)

Output:
-  AdjacencyMatrix: `BatchSize*heads*ROIs*ROIs`

Allocate the heads with the `sigmoid` value outputted by the SE network.

## Deep-GCN

GCN with ResNets and dilated kernels.

input: 
-  AdjacencyMatrix: `BatchSize*heads*ROIs*ROIs`
-  features: `BatchSize*heads*ROIs*BOLDs`
-  dilated parameter: `k`

output:
-  `BatchSize*ROIs*Features(Features=16*heads)`
## Dimension Reduction

input:
-  `BatchSize*ROIs*Features(features=16*heads)`

Output:
-  `BatchSize*ROIs/4*SUVR`

## Final

Input:
-  `BatchSize*ROIs/4*SUVR`

Output:
-  `BatchSize*ROIs*SUVR`

We can firstly predict only a parts of the SUVR then predict the whole level SUVR by linear transformation and non-linear transformation. 